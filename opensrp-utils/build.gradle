apply plugin: 'com.android.library'
apply plugin: 'jacoco'
apply plugin: 'com.github.kt3k.coveralls'
apply plugin: 'maven-publish'
apply plugin: 'signing'

// Ensure module explicitly carries coordinates
group = project.findProperty('GROUP') ?: 'io.github.bluecodesystems'
version = project.findProperty('VERSION_NAME') ?: '0.0.6'


jacoco {
    toolVersion = "0.8.2"
}

android {
    compileSdk Integer.parseInt(project.ANDROID_BUILD_SDK_VERSION)
    namespace 'org.smartregister.client.utils'

    defaultConfig {
        minSdk androidMinSdkVersion
        targetSdk Integer.parseInt(project.ANDROID_BUILD_TARGET_SDK_VERSION)
        versionCode 1
        versionName version

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        consumerProguardFiles "consumer-rules.pro"
    }

    buildTypes {
        release {
            minifyEnabled false
            testCoverageEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            testCoverageEnabled true
            minifyEnabled false
        }
    }

    compileOptions {
        coreLibraryDesugaringEnabled true
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }

    testOptions {
        unitTests.includeAndroidResources = true
    }

    lint {
        abortOnError = false
    }

    // Expose the release variant to Gradle's maven-publish
    publishing {
        singleVariant("release")
    }
}

dependencies {
    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test:runner:1.5.2'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
    implementation 'androidx.annotation:annotation:1.7.0'

    // Core library desugaring for Java 8+ APIs on older Android devices
    coreLibraryDesugaring 'com.android.tools:desugar_jdk_libs:2.0.4'
}

tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
    testLogging {
        // to see the exceptions of failed tests in Travis-CI console.
        exceptionFormat = 'full'
    }
}


task jacocoTestReport(type: JacocoReport, dependsOn: ['testDebugUnitTest']) {

    reports {
        xml.required.set(true)
        // Write a single XML report file for Coveralls consumption
        xml.outputLocation.set(file("${buildDir}/reports/jacoco/jacocoRootReport/merged.xml"))
        html.required.set(true)
        html.outputLocation.set(file("${buildDir}/reports/jacoco/jacocoRootReport/html"))
    }

    def fileFilter = ['**/R.class', '**/R$*.class', '**/BuildConfig.*', '**/Manifest*.*', '**/*Test*.*', 'android/**/*.*', '**/*$ViewBinder*.*']
    def debugTree = fileTree(dir: "$project.buildDir/intermediates/javac/debug", excludes: fileFilter)
    def mainSrc = "$project.projectDir/src/main/java"

    sourceDirectories.setFrom(files([mainSrc]))
    classDirectories.setFrom(files([debugTree]))
    executionData.setFrom(fileTree(dir: project.buildDir, includes: [
            'jacoco/testDebugUnitTest.exec',
            'outputs/code-coverage/**/*.ec',
            'outputs/unit_test_code_coverage/**/*.exec'
    ]))
    sourceDirectories.setFrom([mainSrc])
}


coveralls {
    jacocoReportPath = "${buildDir}/reports/jacoco/jacocoRootReport/merged.xml"
    // Re-add the line below if coveralls still cannot shows "No source file found on the project: "p2p-sync"
    // after adding some code files
    //sourceDirs += ["src/main/java"]
}

def isReleaseBuild() {
    return version.contains("SNAPSHOT") == false
}

// Derive a release-looking version for local bundle/zip names
def releaseVersion = (project.findProperty('VERSION_NAME') ?: project.version).toString().replace('-SNAPSHOT','')

publishing {
    publications {
        release(MavenPublication) {
            // Publish Android 'release' component after components are created
            afterEvaluate {
                from components.release
            }
            groupId = project.GROUP
            artifactId = project.POM_SETTING_ARTIFACT_ID
            // Use a non-SNAPSHOT version inside the local bundle
            version = releaseVersion

            pom {
                name.set(project.findProperty('POM_SETTING_NAME')?.toString() ?: project.name)
                description.set(project.findProperty('POM_SETTING_DESCRIPTION')?.toString() ?: '')
                url.set(project.findProperty('POM_SETTING_URL')?.toString() ?: '')
                licenses {
                    license {
                        name.set(project.findProperty('POM_SETTING_LICENCE_NAME')?.toString() ?: 'Apache-2.0')
                        url.set(project.findProperty('POM_SETTING_LICENCE_URL')?.toString() ?: 'http://www.apache.org/licenses/LICENSE-2.0.txt')
                        distribution.set(project.findProperty('POM_SETTING_LICENCE_DIST')?.toString() ?: 'repo')
                    }
                }
                scm {
                    url.set(project.findProperty('POM_SETTING_SCM_URL')?.toString() ?: '')
                    connection.set(project.findProperty('POM_SETTING_SCM_CONNECTION')?.toString() ?: '')
                    developerConnection.set(project.findProperty('POM_SETTING_SCM_DEV_CONNECTION')?.toString() ?: '')
                }
                developers {
                    developer {
                        id.set(project.findProperty('POM_SETTING_DEVELOPER_ID')?.toString() ?: 'dev')
                        name.set(project.findProperty('POM_SETTING_DEVELOPER_NAME')?.toString() ?: 'Developer')
                    }
                }
            }
        }
    }
    repositories {
        maven {
            name = "CentralBundle"
            url = layout.buildDirectory.dir("central-bundle")
        }
    }
}

// Sign the publication so the bundle has .asc files (required by Central Portal)
afterEvaluate {
    signing {
        // Require signing when publishing the bundle
        required { gradle.taskGraph.hasTask(":opensrp-utils:publishReleasePublicationToCentralBundleRepository") }
        // Always use local GPG for signing as requested
        useGpgCmd()
        // Sign all publications to include .module signatures as well
        sign publishing.publications
    }
}

// Zip the local bundle for upload/sharing (similar to MaterialEditText)
// Optionally generate legacy checksums for OSSRH (md5/sha1)
tasks.register("generateCentralBundleChecksums") {
    dependsOn tasks.named("publishReleasePublicationToCentralBundleRepository")
    doLast {
        def repoDir = layout.buildDirectory.dir("central-bundle").get().asFile
        if (!repoDir.exists()) return
        repoDir.eachFileRecurse { f ->
            if (f.isFile() && !(f.name.endsWith('.md5') || f.name.endsWith('.sha1') || f.name.endsWith('.asc'))) {
                def md5 = java.security.MessageDigest.getInstance('MD5')
                def sha1 = java.security.MessageDigest.getInstance('SHA-1')
                f.withInputStream { is ->
                    byte[] buf = new byte[8192]
                    int r
                    while ((r = is.read(buf)) > 0) {
                        md5.update(buf, 0, r)
                        sha1.update(buf, 0, r)
                    }
                }
                def toHex = { bytes -> bytes.collect { String.format('%02x', it) }.join() }
                new File(f.parentFile, f.name + '.md5').text = toHex(md5.digest())
                new File(f.parentFile, f.name + '.sha1').text = toHex(sha1.digest())
            }
        }
    }
}

tasks.register("zipCentralBundle", Zip) {
    dependsOn tasks.named("generateCentralBundleChecksums")
    // Only include current GAV path, matching Simprints approach
    def groupPath = project.group.toString().replace('.', '/')
    def artifact = (project.findProperty('POM_SETTING_ARTIFACT_ID') ?: project.name).toString()
    def versionDir = "${groupPath}/${artifact}/${releaseVersion}/**"
    from(layout.buildDirectory.dir("central-bundle")) {
        include versionDir
    }
    destinationDirectory = layout.buildDirectory.dir("distributions")
    archiveBaseName.set("central-bundle-${project.POM_SETTING_ARTIFACT_ID}")
    // Ensure zip file name doesn't include -SNAPSHOT
    archiveVersion.set(releaseVersion)
}

// Helper to print out the bundle path and verify contents
tasks.register("printCentralBundleLayout") {
    dependsOn tasks.named("publishReleasePublicationToCentralBundleRepository")
    doLast {
        def base = layout.buildDirectory.dir("central-bundle").get().asFile
        def path = new File(base, project.group.toString().replace('.', '/') + "/" + (project.findProperty('POM_SETTING_ARTIFACT_ID') ?: project.name) + "/" + releaseVersion)
        println "Bundle path: ${path}"
        if (path.exists()) {
            path.eachFile { println it.name }
        } else {
            println "Bundle path not found. Check group/artifact/version."
        }
    }
}

// Publishing has been removed from this module to keep assemble green.
// Re-add Vanniktech Maven Publish when publishing is required.
