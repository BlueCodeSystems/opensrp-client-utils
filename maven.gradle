import org.gradle.api.tasks.bundling.Zip

apply plugin: 'maven-publish'
apply plugin: 'signing'

def isReleaseBuild() {
  !version.toString().contains('SNAPSHOT')
}

def getRepositoryUsername() {
  hasProperty('sonatypeUsername') ? sonatypeUsername : ''
}

def getRepositoryPassword() {
  hasProperty('sonatypePassword') ? sonatypePassword : ''
}

def isSkipSigning() {
  hasProperty('skipSigning') && project.property('skipSigning').toString().toBoolean()
}

def hasNonEmptyProperty(String name) {
  def value = project.findProperty(name)
  value != null && value.toString().trim()
}

def hasSigningCredentials() {
  hasNonEmptyProperty('signing.gnupg.keyName') ||
    (hasNonEmptyProperty('signing.keyId') && hasNonEmptyProperty('signing.password') && hasNonEmptyProperty('signing.secretKeyRingFile')) ||
    (hasNonEmptyProperty('signingKey') && hasNonEmptyProperty('signingPassword'))
}

def isSigningEnabled() {
  if (isSkipSigning()) {
    return false
  }
  project.hasProperty('enableSigning') && project.property('enableSigning').toString().toBoolean() && hasSigningCredentials()
}

plugins.withId('com.android.library') {
  android {
    publishing {
      singleVariant('release') {
        withSourcesJar()
        withJavadocJar()
      }
    }
  }
}

afterEvaluate {
  publishing {
    publications {
      maven(MavenPublication) {
        from components.release
        artifactId = project.POM_SETTING_ARTIFACT_ID
        pom {
          name = project.POM_SETTING_NAME
          packaging = project.POM_SETTING_PACKAGING
          description = project.POM_SETTING_DESCRIPTION
          url = project.POM_SETTING_URL
          scm {
            url = project.POM_SETTING_SCM_URL
            connection = project.POM_SETTING_SCM_CONNECTION
            developerConnection = project.POM_SETTING_SCM_DEV_CONNECTION
          }
          licenses {
            license {
              name = project.POM_SETTING_LICENCE_NAME
              url = project.POM_SETTING_LICENCE_URL
              distribution = project.POM_SETTING_LICENCE_DIST
            }
          }
          developers {
            developer {
              id = project.POM_SETTING_DEVELOPER_ID
              name = project.POM_SETTING_DEVELOPER_NAME
            }
          }
        }
      }
    }
    repositories {
      if (project.hasProperty('centralBundle') && project.property('centralBundle').toString() == 'true') {
        maven {
          name = 'CentralBundle'
          url = layout.buildDirectory.dir('central-bundle')
        }
      } else {
        maven {
          def releaseUrl = 'https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/'
          def snapshotUrl = 'https://s01.oss.sonatype.org/content/repositories/snapshots/'
          url = uri(isReleaseBuild() ? releaseUrl : snapshotUrl)
          credentials {
            username = getRepositoryUsername()
            password = getRepositoryPassword()
          }
        }
      }
    }
  }

  signing {
    if (isSigningEnabled()) {
      if (project.hasProperty('useGpgCmd') && project.property('useGpgCmd').toString().toBoolean()) {
        useGpgCmd()
      }
      required { isReleaseBuild() }
      sign publishing.publications.maven
    } else {
      logger.lifecycle('Skipping PGP signing because key material is not configured or signing was not explicitly enabled (-PenableSigning=true)')
    }
  }

  tasks.register('packageReleaseZip', Zip) {
    group = 'distribution'
    description = 'Packages release AAR, POM, sources and javadoc into a zip'
    dependsOn 'assembleRelease', 'sourceReleaseJar', 'javaDocReleaseJar', 'generatePomFileForMavenPublication'
    from("${buildDir}/outputs/aar") { include '*-release.aar' }
    from("${buildDir}/publications/maven") { include 'pom-default.xml'; into('maven') }
    from("${buildDir}/libs") { include '*-sources.jar', '*-javadoc.jar' }
    def artifactId = project.POM_SETTING_ARTIFACT_ID
    def versionName = project.version?.toString() ?: project.VERSION_NAME
    archiveBaseName.set(artifactId)
    archiveVersion.set(versionName)
    destinationDirectory.set(file("${buildDir}/releasePackage"))
  }

  tasks.register('generateCentralBundleChecksums') {
    group = 'publishing'
    description = 'Generates SHA-256 and SHA-512 checksums for the Central bundle'
    doLast {
      def bundleDir = layout.buildDirectory.dir('central-bundle').get().asFile
      if (!bundleDir.exists()) {
        logger.lifecycle("Central bundle directory not found: ${bundleDir}")
        return
      }
      bundleDir.eachFileRecurse { file ->
        if (file.isFile()) {
          ['SHA-256':'sha256', 'SHA-512':'sha512'].each { alg, ext ->
            def digest = java.security.MessageDigest.getInstance(alg)
            file.withInputStream { is ->
              byte[] buffer = new byte[8192]
              int read
              while ((read = is.read(buffer)) != -1) {
                digest.update(buffer, 0, read)
              }
            }
            new File(file.parentFile, "${file.name}.${ext}").text = digest.digest().collect { String.format('%02x', it) }.join()
          }
        }
      }
      logger.lifecycle('Checksums generated')
    }
  }

  tasks.register('zipCentralBundle', Zip) {
    group = 'publishing'
    description = 'Zips the Central bundle directory for manual upload'
    dependsOn 'generateCentralBundleChecksums'
    def artifactId = project.POM_SETTING_ARTIFACT_ID
    def versionName = project.version?.toString() ?: project.VERSION_NAME
    archiveFileName.set("central-bundle-${artifactId}-${versionName}.zip")
    from(layout.buildDirectory.dir('central-bundle'))
    destinationDirectory.set(file("${buildDir}/distributions"))
  }
}
